/*
 * board_health_adc.c
 *
 *  Created on: Jan 8, 2026
 *      Author: Sterm
 */


#include "board_health/board_health_adc.h"
#include "stm32g4xx_hal.h"



/* ADC handle generated by CubeMX */
extern ADC_HandleTypeDef hadc1;

/* ---- Costanti hardware (Rule 12.1: Uso di parentesi per chiarezza) ---- */
#define ADC_MAX_COUNTS     4095.0f
#define TEMP_MIN_DEGC     (-40.0f)
#define TEMP_MAX_DEGC     (125.0f)
#define BATT_MIN_V        (7.0f)
#define BATT_MAX_V        (15.0f)
#define BATT_DIVIDER_GAIN ((14700.0f + 4700.0f) / 4700.0f)

/* Indirizzi di calibrazione STM32G4 (Esempio, verificare su Reference Manual) */
#define VREFINT_CAL_ADDR_VAL    ((uint16_t *)((uint32_t)0x1FFF75AAU))
#define TSENSE_CAL1_ADDR_VAL    ((uint16_t *)((uint32_t)0x1FFF75A8U))
#define TSENSE_CAL2_ADDR_VAL    ((uint16_t *)((uint32_t)0x1FFF75CAU))

/* ---------- Moving average state (file-local) ---------- */
#define TEMP_MA_WINDOW  10U
#define BATT_MA_WINDOW  10U

/* Mappatura fissa */
#define ADC_RAW_VREF   0
#define ADC_RAW_TEMP   1
#define ADC_RAW_BATT   2

static float temp_ma_buf[TEMP_MA_WINDOW];
static float batt_ma_buf[BATT_MA_WINDOW];
static uint8_t temp_ma_idx = 0U;
static uint8_t temp_ma_cnt = 0U;
static uint8_t batt_ma_idx = 0U;
static uint8_t batt_ma_cnt = 0U;

/* ---------- LUT batteria ---------- */
static const float batt_pct_lut[]  = { 0.0f, 10.0f, 20.0f, 30.0f, 45.0f, 65.0f, 80.0f, 90.0f, 100.0f };
static const float batt_volt_lut[] = { 9.9f, 10.5f, 10.8f, 11.1f, 11.4f, 11.7f, 12.0f, 12.3f, 12.6f };
#define BATT_LUT_SIZE (sizeof(batt_pct_lut)/sizeof(batt_pct_lut[0]))


/* Raw ADC aggiornati dal DMA */
static uint16_t adc_raw[3] = {0U, 0U, 0U};
static uint16_t vrefint_cal = 0U;
static uint16_t tcal1 = 0U;
static uint16_t tcal2 = 0U;

volatile uint8_t adc_ready = 0;

static void BoardHealthADC_LoadCal(void)
{
    /* Rule 11.4: Conversione tra intero e puntatore ammessa per registri/calibrazione */
    vrefint_cal = *VREFINT_CAL_ADDR_VAL;
    tcal1       = *TSENSE_CAL1_ADDR_VAL;
    tcal2       = *TSENSE_CAL2_ADDR_VAL;
}

void BoardHealthADC_Init(void)
{
    BoardHealthADC_LoadCal();
    /* Rule 11.1: Conversione a (uint32_t *) per l'API HAL Ã¨ necessaria */
    (void)HAL_ADC_Start_DMA(&hadc1, (uint32_t *)((void *)adc_raw), 3U);
}



static float MovingAverage_Update(float * const buf, uint8_t size, uint8_t * const idx, uint8_t * const count, float sample)
{
    buf[*idx] = sample;
    *idx = (*idx + 1U) % size;

    if (*count < size){
        *count = *count + 1U;
    }

    float sum = 0.0f;
    for (uint8_t i = 0U; i < *count; i++)
    {
        sum += buf[i];
    }

    return (sum / (float)(*count));
}

static float Battery_VoltageToPercent(float v)
{
    float result = 0.0f;

    if (v <= batt_volt_lut[0])
    {
        const float dv = batt_volt_lut[1] - batt_volt_lut[0];
        const float dp = batt_pct_lut[1]  - batt_pct_lut[0];
        result = batt_pct_lut[0] + ((dp * (v - batt_volt_lut[0])) / dv);
    }
    else if (v >= batt_volt_lut[BATT_LUT_SIZE - 1U])
    {
        const uint8_t i = (uint8_t)BATT_LUT_SIZE - 2U;
        const float dv = batt_volt_lut[i + 1U] - batt_volt_lut[i];
        const float dp = batt_pct_lut[i + 1U]  - batt_pct_lut[i];
        result = batt_pct_lut[i] + ((dp * (v - batt_volt_lut[i])) / dv);
    }
    else
    {
        for (uint8_t i = 0U; i < (BATT_LUT_SIZE - 1U); i++)
        {
            if ((v >= batt_volt_lut[i]) && (v <= batt_volt_lut[i + 1U]))
            {
                const float dv = batt_volt_lut[i + 1U] - batt_volt_lut[i];
                const float dp = batt_pct_lut[i + 1U]  - batt_pct_lut[i];
                result = batt_pct_lut[i] + ((dp * (v - batt_volt_lut[i])) / dv);
                break; /* Rule 15.1: Break ammesso per uscire dai cicli di ricerca */
            }
        }
    }

    /* Clamp del risultato per sicurezza */
    if (result > 100.0f) { result = 100.0f; }
    if (result < 0.0f)   { result = 0.0f; }

    return result;
}



BoardHealthStatus_t BoardHealth_ReadTemperature(float * const temp_degC)
{
    BoardHealthStatus_t status = BOARD_HEALTH_OK;

    if (temp_degC == (void *)0)
    {
        status = BOARD_HEALTH_ADC_ERROR;
    }
    else
    {
        /* Lettura atomica dei valori DMA (Prevenzione race conditions) */
        __disable_irq();
        const uint32_t raw_vref = (uint32_t)adc_raw[ADC_RAW_VREF];
        const uint32_t raw_temp = (uint32_t)adc_raw[ADC_RAW_TEMP];
        __enable_irq();

        if (raw_vref == 0U)
        {
            status = BOARD_HEALTH_ADC_ERROR;
        }
        else
        {
            const float vdda = 3.0f * ((float)vrefint_cal / (float)raw_vref);
            const float adc_temp_at_3v = (float)raw_temp * (vdda / 3.0f);

            /* Calcolo temperatura da datasheet STM32G4 */
            const float temp_raw = (80.0f * (adc_temp_at_3v - (float)tcal1) / (float)(tcal2 - tcal1)) + 30.0f;

            const float temp_filt = MovingAverage_Update(temp_ma_buf, (uint8_t)TEMP_MA_WINDOW, &temp_ma_idx, &temp_ma_cnt, temp_raw);

            if ((temp_filt < TEMP_MIN_DEGC) || (temp_filt > TEMP_MAX_DEGC))
            {
                status = BOARD_HEALTH_OUT_OF_RANGE;
            }
            else
            {
                *temp_degC = temp_filt;
            }
        }
    }
    return status;
}



BoardHealthStatus_t BoardHealth_ReadBattery(float * const battery_pct)
{
    BoardHealthStatus_t status = BOARD_HEALTH_OK;

    if (battery_pct == (void *)0)
    {
        status = BOARD_HEALTH_ADC_ERROR;
    }
    else
    {
        __disable_irq();
        const uint32_t raw_vref = (uint32_t)adc_raw[ADC_RAW_VREF];
        const uint32_t raw_batt = (uint32_t)adc_raw[ADC_RAW_BATT];
        __enable_irq();

        if (raw_vref == 0U)
        {
            status = BOARD_HEALTH_ADC_ERROR;
        }
        else
        {
            const float vdda = 3.0f * ((float)vrefint_cal / (float)raw_vref);
            const float v_batt_adc = ((float)raw_batt * vdda) / ADC_MAX_COUNTS;
            const float v_batt = v_batt_adc * BATT_DIVIDER_GAIN;

            if ((v_batt < BATT_MIN_V) || (v_batt > BATT_MAX_V))
            {
                status = BOARD_HEALTH_OUT_OF_RANGE;
            }
            else
            {
                const float v_filt = MovingAverage_Update(batt_ma_buf, (uint8_t)BATT_MA_WINDOW, &batt_ma_idx, &batt_ma_cnt, v_batt);
                *battery_pct = Battery_VoltageToPercent(v_filt);
            }
        }
    }
    return status;
}


