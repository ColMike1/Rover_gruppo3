/*
 * comm_uart.c
 *
 *  Created on: Jan 11, 2026
 *      Author: Sterm
 */


#include "comm/comm_uart.h"
#include "stm32g4xx_hal.h"
#include <stdbool.h>
#include "FreeRTOS.h"
#include "task.h"
#define UART_RX_BUF_SIZE 256

/* UART handle generated by CubeMX */
extern UART_HandleTypeDef huart4;
static volatile bool uart4_tx_busy = false;

static uint8_t rx_byte;                  // byte ricevuto via IRQ
static uint8_t rx_buf[UART_RX_BUF_SIZE]; // ring buffer
static volatile uint16_t rx_wr = 0;
static volatile uint16_t rx_rd = 0;

static TaskHandle_t rx_task_handle = NULL;

void CommUart_RegisterRxTask(TaskHandle_t h)
{
    rx_task_handle = h;
}

void CommUart_EarlyInit(void)
{
    rx_wr = 0;
    rx_rd = 0;
    rx_task_handle = NULL;
    uart4_tx_busy = false;
    HAL_UART_Receive_IT(&huart4, &rx_byte, 1);
}


void CommUart_Init(void)
{

    CommUart_RegisterRxTask(xTaskGetCurrentTaskHandle());
}

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart == &huart4)
    {
        uart4_tx_busy = false;
    }
}


void CommUart_Send(const uint8_t *buf, uint16_t len)
{
    if (!buf || len == 0)
        return;

    /* Blocking TX: la CPU resta qui finch√© non finisce */
    HAL_UART_Transmit_IT(&huart4, (uint8_t *)buf, len);
}


void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart == &huart4)
    {
        uint16_t next = (rx_wr + 1) % UART_RX_BUF_SIZE;

        if (next != rx_rd)   // no overflow
        {
            rx_buf[rx_wr] = rx_byte;
            rx_wr = next;
        }

        BaseType_t hpw = pdFALSE;
        if (rx_task_handle)
            vTaskNotifyGiveFromISR(rx_task_handle, &hpw);

        HAL_UART_Receive_IT(&huart4, &rx_byte, 1);

        portYIELD_FROM_ISR(hpw);
    }
}

bool CommUart_GetByte(uint8_t *b)
{
    if (rx_rd == rx_wr)
        return false;

    *b = rx_buf[rx_rd];
    rx_rd = (rx_rd + 1) % UART_RX_BUF_SIZE;
    return true;
}
