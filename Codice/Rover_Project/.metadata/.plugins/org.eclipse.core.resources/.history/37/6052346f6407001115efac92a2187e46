/*
 * comm_rx_task.c
 *
 *  Created on: Jan 11, 2026
 *      Author: Sterm
 */


#include "comm/comm_rx_task.h"
#include "comm/comm_unpack.h"
#include "comm/comm_uart.h"

#include "snapshot/rx_snapshot.h"
#include <stdio.h>
#include "cmsis_os2.h"

#include "FreeRTOS.h"
#include "task.h"
#include "stm32g4xx.h"

#include "log/wcet_monitor.h"
#define SYNC_WORD   0xAA55
#define RX_FRAME_LEN (sizeof(CommFrameB1_t))

void Rx_TaskInit(void){

	CommUart_Init();

}

/*
void Debug_DumpAccBuf(const uint8_t *buf, uint16_t len)
{
    printf("ACC_BUF (len=%u): ", len);

    for (uint16_t i = 0; i < len; i++)
    {
        printf("%02X ", buf[i]);
    }

    printf("\r\n");
}
*/
void Rx_TaskStep(void)
{


    static RxSnapshot_t snap;
    static uint8_t acc_buf[RX_FRAME_LEN];
    static uint16_t acc_len = 0;

    uint8_t byte;

    /* blocca finchÃ© arriva almeno un byte */
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    uint32_t s = DWT->CYCCNT;

    while (CommUart_GetByte(&byte))
    {
        /* ================= SYNC ================= */
        if (acc_len < sizeof(uint16_t))
        {
            acc_buf[acc_len++] = byte;

            if (acc_len == 2)
            {
                uint16_t sync = acc_buf[0] | (acc_buf[1] << 8);
                if (sync != SYNC_WORD)
                {
                    acc_buf[0] = acc_buf[1];
                    acc_len = 1;
                }
            }
            continue;
        }

        /* ============= RESTO FRAME ============== */
        acc_buf[acc_len] = byte;

        //Check se incontro sync word durante il payload (magari ho perso dei byte)
        uint16_t w = acc_buf[acc_len-1] | (acc_buf[acc_len] << 8);

        if (w == SYNC_WORD)
        	{
        	acc_buf[0] = acc_buf[acc_len-1];
        	acc_buf[1] = acc_buf[acc_len];
        	acc_len = 2;
        	continue;
        	}

        acc_len ++;

        if (acc_len < RX_FRAME_LEN)
            continue;

        /* ============= FRAME COMPLETO ============ */
        //Debug_DumpAccBuf(acc_buf, acc_len);
        uint32_t now = osKernelGetTickCount();
        snap.task_last_run_ms = now;

        CommFrameHeader_t hdr;
        CommPayloadB1_t   pl;

        CommUnpackStatus_t st =
            CommUnpack_B2FromB1(acc_buf, RX_FRAME_LEN, &hdr, &pl);

        snap.last_event = st;

        if (st == COMM_UNPACK_OK)
        {
            snap.payload = pl;
            snap.data_last_valid_ms = now;
        }

        acc_len = 0;   // pronto per il prossimo frame
        RxSnapshot_Write(&snap);
        WCET_Update(WCET_TASK_RX, DWT->CYCCNT - s);
    }
}
