/*
 * comm_rx_task.c
 *
 *  Created on: Jan 11, 2026
 *      Author: Sterm
 */



#include "comm/comm_rx_task.h"
#include "comm/comm_unpack.h"
#include "comm/comm_uart.h"

#include "snapshot/rx_snapshot.h"
#include <stdio.h>

#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os2.h"
#define RX_FRAME_LEN (sizeof(CommFrameB2_t))
#define SYNC_WORD   0xAA56

/* ===== API ===== */

void Rx_TaskInit(void){

	CommUart_Init();

}

void Debug_DumpAccBuf(const uint8_t *buf, uint16_t len)
{
    printf("ACC_BUF (len=%u): ", len);

    for (uint16_t i = 0; i < len; i++)
    {
        printf("%02X ", buf[i]);
    }

    printf("\r\n");
}

void Rx_TaskStep(void)
{
    static RxSnapshot_t snap;
    static uint8_t acc_buf[RX_FRAME_LEN];
    static uint16_t acc_len = 0;

    uint8_t byte;

    /* blocca finchÃ© arriva almeno un byte */
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    while (CommUart_GetByte(&byte))
    {
        /* ================= SYNC ================= */
        if (acc_len < 2)
        {
            acc_buf[acc_len++] = byte;

            if (acc_len == 2)
            {
                uint16_t sync = acc_buf[0] | (acc_buf[1] << 8);
                if (sync != SYNC_WORD)
                {
                    acc_buf[0] = acc_buf[1];
                    acc_len = 1;
                }
            }
            continue;
        }

        /* ============= RESTO FRAME ============== */
        acc_buf[acc_len++] = byte;

        uint16_t w = acc_buf[acc_len-2] | (acc_buf[acc_len-1] << 8);

        if (w == SYNC_WORD)                 // aggiunto
        	{
        	acc_buf[0] = acc_buf[acc_len-2];
        	acc_buf[1] = acc_buf[acc_len-1];
        	acc_len = 2;                    // aggiunto
        	continue;                       // aggiunto
        	}

        if (acc_len < RX_FRAME_LEN)
            continue;

        /* ============= FRAME COMPLETO ============ */
        Debug_DumpAccBuf(acc_buf, acc_len);
        uint32_t now = osKernelGetTickCount();
        snap.task_last_run_ms = now;

        CommFrameHeader_t hdr;
        CommPayloadB2_t   pl;

        CommUnpackStatus_t st =
            CommUnpack_B1FromB2(acc_buf, RX_FRAME_LEN, &hdr, &pl);

        snap.last_event = st;

        if (st == COMM_UNPACK_OK)
        {
            snap.payload = pl;
            snap.data_last_valid_ms = now;
        }

        acc_len = 0;   // pronto per il prossimo frame
        RxSnapshot_Write(&snap);
    }
}
