/*
 * sabertooth_driver.c
 *
 *  Created on: Jan 12, 2026
 *      Author: Sterm
 */


#include "actuation/sabertooth_driver.h"
#include "stm32g4xx_hal.h"
#include <math.h>
#include <string.h>

/* UART generata da CubeMX */
extern UART_HandleTypeDef huart5;

/* ===== TX buffers ===== */
static uint8_t saber_tx_active[16];   /* buffer attualmente in trasmissione */
static uint8_t saber_tx_next[16];     /* ultimo comando preparato */
static volatile uint8_t tx_busy = 0;
static volatile uint8_t tx_pending = 0;

/* === Checksum Sabertooth === */
static inline uint8_t Saber_Checksum(uint8_t a, uint8_t b, uint8_t c)
{
    return (a + b + c) & 0x7F;
}

/* === Prepara pacchetto singolo === */
static void Prepare_Saber_Packet(uint8_t *dest,
                                 uint8_t addr,
                                 uint8_t cmd,
                                 float value)
{
    int speed = (int)lroundf(value);

    if (speed > SABER_MAX_SPEED) speed = SABER_MAX_SPEED;
    if (speed < 0)               speed = 0;

    dest[0] = addr;
    dest[1] = cmd;
    dest[2] = (uint8_t)speed;
    dest[3] = Saber_Checksum(dest[0], dest[1], dest[2]);
}

void Sabertooth_Init(void)
{
	uint8_t saber_timeout_pkt[4];

    Prepare_Saber_Packet(saber_timeout_pkt, SABER_BACK_ADDR, 14, 3);
    HAL_UART_Transmit(&huart5, saber_timeout_pkt, 4, HAL_MAX_DELAY);

    Prepare_Saber_Packet(saber_timeout_pkt, SABER_FRONT_ADDR, 14, 3);
    HAL_UART_Transmit(&huart5, saber_timeout_pkt, 4, HAL_MAX_DELAY);
}

/* === helper: prova ad avviare una TX usando active === */
static void Sabertooth_StartTxActive(void)
{
    tx_busy = 1;
    HAL_StatusTypeDef st = HAL_UART_Transmit_IT(&huart5, saber_tx_active, sizeof(saber_tx_active));
    if (st != HAL_OK	)
    {
        /* Se fallisce, rilascia busy e riproveremo al prossimo giro */
        tx_busy = 0;
    }
}


void Sabertooth_ApplyOutputs(float usx_a, float udx_a, float usx_p, float udx_p)
{
    /* Mapping Voltaggio -> Sabertooth serial packet [0..127]
	*/
    float s_sx_p = (fabsf(usx_p) / 12) * 127.0f;
    float s_dx_p = (fabsf(udx_p) / 12) * 127.0f;
    float s_sx_a = (fabsf(usx_a) / 12) * 127.0f;
    float s_dx_a = (fabsf(udx_a) / 12) * 127.0f;


    Prepare_Saber_Packet(&saber_tx_next[0], SABER_BACK_ADDR, (usx_p >= 0.0f ? 0 : 1), s_sx_p);
    Prepare_Saber_Packet(&saber_tx_next[4], SABER_BACK_ADDR, (udx_p >= 0.0f ? 4 : 5), s_dx_p);
    Prepare_Saber_Packet(&saber_tx_next[8], SABER_FRONT_ADDR, (usx_a >= 0.0f ? 0 : 1), s_sx_a);
    Prepare_Saber_Packet(&saber_tx_next[12], SABER_FRONT_ADDR, (udx_a >= 0.0f ? 4 : 5), s_dx_a);


    /* Se UART è occupata, segna pending e basta (verrà inviato a fine TX) */
    if (tx_busy)
    {
        tx_pending = 1;
        return;
    }

    /* UART libera: copia next -> active e trasmetti */
    memcpy(saber_tx_active, saber_tx_next, sizeof(saber_tx_active));
    tx_pending = 0;
    Sabertooth_StartTxActive();
}

void SaberTxCallback(void){
    tx_busy = 0;

    /* Se durante la TX è arrivato un aggiornamento, invia l’ultimo next */
    if (tx_pending)
    {
        memcpy(saber_tx_active, saber_tx_next, sizeof(saber_tx_active));
        tx_pending = 0;
        Sabertooth_StartTxActive();
    }
}
/* Callback HAL: TX completata */
/*
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart != &huart5) return;

    tx_busy = 0;

    // Se durante la TX è arrivato un aggiornamento, invia l’ultimo next
    if (tx_pending)
    {
        memcpy(saber_tx_active, saber_tx_next, sizeof(saber_tx_active));
        tx_pending = 0;
        Sabertooth_StartTxActive();
    }
}
*/

