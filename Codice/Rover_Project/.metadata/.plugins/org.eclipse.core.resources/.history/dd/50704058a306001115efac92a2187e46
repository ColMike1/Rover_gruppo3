/*
 * board_health_adc.c
 *
 *  Created on: Jan 8, 2026
 *      Author: Sterm
 */


#include "board_health/board_health_adc.h"
#include "stm32g4xx_hal.h"



/* ADC handle generated by CubeMX */
extern ADC_HandleTypeDef hadc1;

/* ---- Costanti hardware ---- */
#define ADC_MAX_COUNTS     4095.0f

/* Temperature sensor limits (datasheet) */
#define TEMP_MIN_DEGC     (-40.0f)
#define TEMP_MAX_DEGC     (125.0f)

/* Battery limits (esempio, adattali al tuo sistema) */
#define BATT_MIN_V        (7.0f)
#define BATT_MAX_V        (15.0f)
#define BATT_MA_WINDOW 10


/* Partitore: (R1 + R2) / R2 */
#define BATT_DIVIDER_GAIN ((14700.0f + 4700.0f) / 4700.0f)


/* ---------- Moving average state (file-local) ---------- */
#define TEMP_MA_WINDOW  10
#define BATT_MA_WINDOW  10

static float temp_ma_buf[TEMP_MA_WINDOW];
static float batt_ma_buf[BATT_MA_WINDOW];

static uint8_t temp_ma_idx = 0, temp_ma_cnt = 0;
static uint8_t batt_ma_idx = 0, batt_ma_cnt = 0;

/* ---------- LUT batteria ---------- */
static const float batt_pct_lut[]  = { 0, 10, 20, 30, 45, 65, 80, 90, 100 };
static const float batt_volt_lut[] = { 9.9, 10.5, 10.8, 11.1, 11.4, 11.7, 12.0, 12.3, 12.6 };
#define BATT_LUT_SIZE (sizeof(batt_pct_lut)/sizeof(batt_pct_lut[0]))


/* Raw ADC aggiornati dal DMA */
static uint16_t adc_raw[3];


static uint16_t vrefint_cal;
static uint16_t tcal1;
static uint16_t tcal2;

/* Mappatura fissa */
#define ADC_RAW_VREF   0
#define ADC_RAW_TEMP   1
#define ADC_RAW_BATT   2

volatile uint8_t adc_ready = 0;

static void BoardHealthADC_LoadCal(void)
{
    vrefint_cal = *VREFINT_CAL_ADDR;
    tcal1       = *TEMPSENSOR_CAL1_ADDR;
    tcal2       = *TEMPSENSOR_CAL2_ADDR;
}

/* --- API pubblica --- */
void BoardHealthADC_Init(void)
{
    BoardHealthADC_LoadCal();
    HAL_ADC_Start_DMA(&hadc1, (uint32_t *)adc_raw, 3);
}




static float MovingAverage_Update(float *buf,
                                  uint8_t size,
                                  uint8_t *idx,
                                  uint8_t *count,
                                  float sample)
{
  buf[*idx] = sample;
  *idx = (*idx + 1U) % size;

  if (*count < size)
    (*count)++;

  float sum = 0.0f;
  for (uint8_t i = 0; i < *count; i++)
    sum += buf[i];

  return sum / (*count);
}


static float Battery_VoltageToPercent(float v)
{
  if (v <= batt_volt_lut[0]) {
    /* extrapolazione lineare sotto */
    float dv = batt_volt_lut[1] - batt_volt_lut[0];
    float dp = batt_pct_lut[1]  - batt_pct_lut[0];
    return batt_pct_lut[0] + dp * (v - batt_volt_lut[0]) / dv;
  }

  if (v >= batt_volt_lut[BATT_LUT_SIZE-1]) {
    /* extrapolazione lineare sopra */
    uint8_t i = BATT_LUT_SIZE - 2;
    float dv = batt_volt_lut[i+1] - batt_volt_lut[i];
    float dp = batt_pct_lut[i+1]  - batt_pct_lut[i];
    return batt_pct_lut[i] + dp * (v - batt_volt_lut[i]) / dv;
  }

  for (uint8_t i = 0; i < BATT_LUT_SIZE-1; i++) {
    if (v >= batt_volt_lut[i] && v <= batt_volt_lut[i+1]) {
      float dv = batt_volt_lut[i+1] - batt_volt_lut[i];
      float dp = batt_pct_lut[i+1]  - batt_pct_lut[i];
      return batt_pct_lut[i] + dp * (v - batt_volt_lut[i]) / dv;
    }
  }

  return 0.0f; /* fallback */
}



BoardHealthStatus_t BoardHealth_ReadTemperature(float *temp_degC)
{
    if (temp_degC == NULL)
        return BOARD_HEALTH_ADC_ERROR;

    uint32_t raw_vref = adc_raw[ADC_RAW_VREF];
    uint32_t raw_temp = adc_raw[ADC_RAW_TEMP];

    /* Sanity minima */
    if (raw_vref == 0U)
        return BOARD_HEALTH_ADC_ERROR;


  float vdda = 3.0f * ((float)vrefint_cal / (float)raw_vref);
  float adc_temp_at_3v = (float)raw_temp * (vdda / 3.0f);

  float temp_raw =
      (80.0f * (adc_temp_at_3v - tcal1) / (float)(tcal2 - tcal1)) + 30.0f;

  /* filtro */
  float temp_filt = MovingAverage_Update(
      temp_ma_buf, TEMP_MA_WINDOW,
      &temp_ma_idx, &temp_ma_cnt,
      temp_raw);

  /* validitÃ  fisica */
  if (temp_filt < TEMP_MIN_DEGC || temp_filt > TEMP_MAX_DEGC)
    return BOARD_HEALTH_OUT_OF_RANGE;

  *temp_degC = temp_filt;
  return BOARD_HEALTH_OK;
}



BoardHealthStatus_t BoardHealth_ReadBattery(float *battery_pct)
{
    if (battery_pct == NULL)
        return BOARD_HEALTH_ADC_ERROR;

    uint32_t raw_vref = adc_raw[ADC_RAW_VREF];
    uint32_t raw_batt = adc_raw[ADC_RAW_BATT];

    if (raw_vref == 0U)
        return BOARD_HEALTH_ADC_ERROR;

  float vdda = 3.0f * ((float)vrefint_cal / (float)raw_vref);

  float v_batt_adc = ((float)raw_batt * vdda) / ADC_MAX_COUNTS;
  float v_batt = v_batt_adc * BATT_DIVIDER_GAIN;

  /* sanity check fisico */
  if (v_batt < BATT_MIN_V || v_batt > BATT_MAX_V)
    return BOARD_HEALTH_OUT_OF_RANGE;

  /* filtro */
  float v_filt = MovingAverage_Update(
      batt_ma_buf, BATT_MA_WINDOW,
      &batt_ma_idx, &batt_ma_cnt,
      v_batt);

  /* LUT */
  float pct = Battery_VoltageToPercent(v_filt);
  printf(
    "[ADC] raw_vref=%lu raw_temp=%lu raw_batt=%lu | "
    "vdda=%.3f V | v_adc=%.3f V | v_batt=%.3f V | filtrata: %.3f | pct: %.2f \r\n",
    raw_vref,
    adc_raw[ADC_RAW_TEMP],
    raw_batt,
    vdda,
    v_batt_adc,
    v_batt,
	  v_filt,
	  v_pct
  );

  *battery_pct = pct;
  return BOARD_HEALTH_OK;
}



