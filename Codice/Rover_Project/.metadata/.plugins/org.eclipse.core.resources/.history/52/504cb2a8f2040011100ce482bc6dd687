/*
 * sonar_hw.c
 *
 *  Created on: Jan 14, 2026
 *      Author: Sterm
 */


#include "sonar/sonar_hw.h"
#include "tim.h"
#include <stdbool.h>
#include "cmsis_os2.h" // Necessario per le funzioni FreeRTOS
#include "FreeRTOS.h"
#include "task.h"
#include "tim.h"
#include "main.h"
#include "log/wcet_monitor.h"
/* ===== HW state ===== */

sonars_flag_t flag;
distances_t distances;
buffer_sonars_t buffers;

// Variabile per contare quanti sonar hanno completato la lettura
uint8_t sonar_count = 0;

distances_t scan(uint32_t c_start)
{
    // 1. DISABILITA gli interrupt per configurare in modo atomico
    __HAL_TIM_DISABLE_IT(&htim1, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3);
    sonar_count = 0;
    flag.sonar1_ok = 0;
    flag.sonar2_ok = 0;
    flag.sonar3_ok = 0;

    while(ulTaskNotifyTake(pdTRUE, 0) > 0);

    memset(&buffers, 0, sizeof(buffers));

    // 2. RE-INIZIALIZZA il DMA1
    HAL_TIM_IC_Stop_DMA(&htim1, TIM_CHANNEL_1);
    HAL_TIM_IC_Stop_DMA(&htim1, TIM_CHANNEL_2);
    HAL_TIM_IC_Stop_DMA(&htim1, TIM_CHANNEL_3);

    HAL_TIM_IC_Start_DMA(&htim1, TIM_CHANNEL_1, (uint32_t*)buffers.buf_ch1, 2);
    HAL_TIM_IC_Start_DMA(&htim1, TIM_CHANNEL_2, (uint32_t*)buffers.buf_ch2, 2);
    HAL_TIM_IC_Start_DMA(&htim1, TIM_CHANNEL_3, (uint32_t*)buffers.buf_ch3, 2);

    // 3. RE-ABILITA e Trigger
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

    // Attesa
	   uint32_t c_end = DWT->CYCCNT;
	   uint32_t wcet_sonar_cpu = c_end - c_start;

	   WCET_Update(WCET_TASK_SONAR, wcet_sonar_cpu);
    ulTaskNotifyTake(pdTRUE, pdMS_TO_TICKS(35));

    // 4. STOP RIGOROSO
    HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);

    // Chiudi tutto subito per evitare interrupt spuri mentre il rover frena
    HAL_TIM_IC_Stop_DMA(&htim1, TIM_CHANNEL_1);
    HAL_TIM_IC_Stop_DMA(&htim1, TIM_CHANNEL_2);
    HAL_TIM_IC_Stop_DMA(&htim1, TIM_CHANNEL_3);

    __HAL_TIM_CLEAR_IT(&htim1, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3);

    // 5. Calcolo (ora sicuro perché gli interrupt sono spenti)
    distances.distance1 = flag.sonar1_ok ? read_distance(buffers.buf_ch1) : 301;
    distances.distance2 = flag.sonar2_ok ? read_distance(buffers.buf_ch2) : 301;
    distances.distance3 = flag.sonar3_ok ? read_distance(buffers.buf_ch3) : 301;

    return distances;
}

uint32_t read_distance(uint16_t* buf){

	uint16_t ic1 = buf[0];
	uint16_t ic2 = buf[1];
    uint16_t width;


	if (ic2 >= ic1)
		width = ic2 - ic1;
	else
		width = (0xFFFF - ic1) + ic2 + 1;

	// TIM4 deve avere un clock di 1MHz. In questo modo la variabile width sarà il numero di microsecondi trascorsi.
	// Distanza in cm =  Width(che è il numero di microsecondi trascorsi) / 58
	return (uint32_t)(width / 58);
}


void SonarHW_GetDistances(uint16_t *d1, uint16_t *d2, uint16_t *d3){
    if (d1) *d1 = distances.distance1;
    if (d2) *d2 = distances.distance2;
    if (d3) *d3 = distances.distance3;
}




