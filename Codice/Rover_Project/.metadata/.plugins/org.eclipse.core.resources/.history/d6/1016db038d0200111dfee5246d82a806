/*
 * imu_i2c.c
 *
 *  Created on: Jan 14, 2026
 *      Author: Sterm
 */

#include <math.h>
#include <IMU/imu_i2c.h>
#include <stdbool.h>
#include "cmsis_os2.h"
/* ================= HAL HANDLES ================= */

extern I2C_HandleTypeDef hi2c3;

/* ================= INTERNAL STATE ================= */

/* Shadow buffer raw */
static uint8_t imu_rx_buf[14];



/* Raw data */
static int16_t accel_raw[3];
static int16_t gyro_raw[3];
static int16_t temp_raw;

/* Scaled values */
static float accel_g[3];
static float gyro_dps[3];
static float temperature_degC;


static float gz_bias = 0.0f;

static float yaw_deg = 0.0f;
static float gyro_z_dps = 0.0f;


static void MPU6050_CalcGyroBias(void)
{
    float sum = 0.0f;
    uint8_t buf[2];

    for (int i = 0; i < 500; i++)
    {
        if (HAL_I2C_Mem_Read(&hi2c3, MPU6050_ADDR,
                             MPU6050_GYRO_ZOUT_H,
                             1, buf, 2, 10) == HAL_OK)
        {
            int16_t raw = (int16_t)(buf[0] << 8 | buf[1]);
            sum += (float)raw / MPU6050_GYRO_SENS_250DPS;
        }
        osDelay(2);
    }

    gz_bias = sum / 500.0f;
}




static void MPU6050_UpdateYaw(float Ts)
{
	float gz_bias2 = -1.292;
    float gz = gyro_dps[2] - gz_bias;

    /* === Deadband === */
    if (fabsf(gz) > 0.3f) {
        yaw_deg -= gz * Ts;
    }

    if (yaw_deg >= 360.0f) yaw_deg -= 360.0f;
    if (yaw_deg < 0.0f)    yaw_deg += 360.0f;
}




static void IMU_I2C_Parse(void)
{
    const uint8_t *buf = imu_rx_buf;

    accel_raw[0] = (int16_t)(buf[0] << 8 | buf[1]);
    accel_raw[1] = (int16_t)(buf[2] << 8 | buf[3]);
    accel_raw[2] = (int16_t)(buf[4] << 8 | buf[5]);

    accel_g[0] = accel_raw[0] / MPU6050_ACCEL_SENS_2G;
    accel_g[1] = accel_raw[1] / MPU6050_ACCEL_SENS_2G;
    accel_g[2] = accel_raw[2] / MPU6050_ACCEL_SENS_2G;

    temp_raw = (int16_t)(buf[6] << 8 | buf[7]);
    temperature_degC = (temp_raw / 340.0f) + 36.53f;

    gyro_raw[0] = (int16_t)(buf[8]  << 8 | buf[9]);
    gyro_raw[1] = (int16_t)(buf[10] << 8 | buf[11]);
    gyro_raw[2] = (int16_t)(buf[12] << 8 | buf[13]);

    gyro_dps[0] = gyro_raw[0] / MPU6050_GYRO_SENS_250DPS;
    gyro_dps[1] = gyro_raw[1] / MPU6050_GYRO_SENS_250DPS;
    gyro_dps[2] = gyro_raw[2] / MPU6050_GYRO_SENS_250DPS;
}




IMUI2CStatus_t IMU_I2C_ReadBlocking(void)
{

    HAL_StatusTypeDef st =
        HAL_I2C_Mem_Read(&hi2c3,
                         MPU6050_ADDR,
                         MPU6050_ACCEL_XOUT_H,
                         1,
                         imu_rx_buf,
                         14,
                         10);

    if (st == HAL_OK){
    	IMU_I2C_Parse();
    	MPU6050_UpdateYaw(0.02f);
    }


    return st;
}



IMUI2CStatus_t IMU_I2C_Init(void)
{
	//uint8_t
    uint8_t who_am_i = 0;
    uint8_t data;


    if (HAL_I2C_Mem_Read(&hi2c3, MPU6050_ADDR,
                         MPU6050_WHO_AM_I, 1,
                         &who_am_i, 1, 10) != HAL_OK)
    {
    	return IMU_I2C_ERROR;

    }

    //dovrebbe essere 0x68 ma legge 112 = 0x70
    if (who_am_i != 0x70)
    {
    	return IMU_I2C_ERROR;
    }

    // Wake up device
    data = 0x00;
    HAL_I2C_Mem_Write(&hi2c3, MPU6050_ADDR,
                      MPU6050_PWR_MGMT_1, 1,
                      &data, 1, 10);

    // Sample rate = 1 kHz
    data = 0x07;
    HAL_I2C_Mem_Write(&hi2c3, MPU6050_ADDR,
                      MPU6050_SMPLRT_DIV, 1,
                      &data, 1, 10);

    // Accel ±2g
    data = 0x00;
    HAL_I2C_Mem_Write(&hi2c3, MPU6050_ADDR,
                      MPU6050_ACCEL_CONFIG, 1,
                      &data, 1, 10);

    // Gyro ±250 dps
    data = 0x00;
    HAL_I2C_Mem_Write(&hi2c3, MPU6050_ADDR,
                      MPU6050_GYRO_CONFIG, 1,
                      &data, 1, 10);



    MPU6050_CalcGyroBias();

    return IMU_I2C_COMPLETE;
}


/* ================= GETTERS ================= */

void IMU_I2C_GetAccel(float *ax_g, float *ay_g, float *az_g)
{
    if (ax_g) *ax_g = accel_g[0];
    if (ay_g) *ay_g = accel_g[1];
    if (az_g) *az_g = accel_g[2];
}

void IMU_I2C_GetGyro(float *gx_dps, float *gy_dps, float *gz_dps)
{
    if (gx_dps) *gx_dps = gyro_dps[0];
    if (gy_dps) *gy_dps = gyro_dps[1];
    if (gz_dps) *gz_dps = gyro_dps[2];
}

float IMU_I2C_GetTemperature(void)
{
    return temperature_degC;
}

float IMU_I2C_GetYaw(void)
{
	//return yaw_deg;
    return yaw_deg;
}

