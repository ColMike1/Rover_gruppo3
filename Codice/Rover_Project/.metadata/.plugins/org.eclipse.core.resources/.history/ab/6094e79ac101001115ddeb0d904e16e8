/*
 * control_step.c
 *
 *  Created on: Jan 12, 2026
 *      Author: Sterm
 */



#include <actuation/actuation_step.h>
#include "control/control.h"
#include "snapshot/encoder_snapshot.h"
#include "snapshot/supervisor_snapshot.h"


#include "snapshot/rx_snapshot.h"
#include <math.h>
#include "cmsis_os2.h"
#include <stdbool.h>


#define MAX_SPEED_RPM  160.0f
#define MAX_TURN_RPM 80.0f


static void Apply_Encoders_Fallback_Actuation(ControlOutput_t *cmd, SupervisorSnapshot_t sup){


    bool fault_fl = sup.degraded_mask & FAULT_WHEEL_FL;
    bool fault_fr = sup.degraded_mask & FAULT_WHEEL_FR;
    bool fault_rl = sup.degraded_mask & FAULT_WHEEL_RL;
    bool fault_rr = sup.degraded_mask & FAULT_WHEEL_RR;

    uint8_t n_fail = fault_fl + fault_fr + fault_rl + fault_rr;

    float *cmd_fl = &cmd->u_sx_a;
    float *cmd_fr = &cmd->u_dx_a;
    float *cmd_rl = &cmd->u_sx_p;
    float *cmd_rr = &cmd->u_dx_p;

    /* === 4 FAIL === */
    if (n_fail == 4) {
    	//Fallimento critico, non ho riferimenti per il pid, unica opzione usare open loop.
    	return;
    }

    /* === 3 FAIL === */
    if (n_fail == 3) {
        float ref;
        if (!fault_fl)
        	ref = *cmd_fl;
        else if (!fault_fr)
        	ref = *cmd_fr;
        else if (!fault_rl)
        	ref = *cmd_rl;
        else
        	ref = *cmd_rr;

        *cmd_fl = *cmd_fr = *cmd_rl = *cmd_rr = ref;
        return;
    }

    /* === 2 FAIL === */
    if (n_fail == 2) {

        /* stesso lato */
        if (fault_fl && fault_rl) {
            *cmd_fl = *cmd_fr;
            *cmd_rl = *cmd_rr;
            return ;
        }

        if (fault_fr && fault_rr) {
            *cmd_fr = *cmd_fl;
            *cmd_rr = *cmd_rl;
            return ;
        }


        /* stesso asse */
        if (fault_rl && fault_rr) {
            *cmd_rl = *cmd_fl;
            *cmd_rr = *cmd_fr;
            return ;
        }
        if (fault_fl && fault_fr) {
            *cmd_fl = *cmd_rl;
            *cmd_fr = *cmd_rr;
            return ;
        }

        /* incrociati */
        if (fault_fl && fault_rr){
        	*cmd_fl = *cmd_rl;
        	*cmd_rr = *cmd_fr;
        	return;
        }

        if(fault_fr && fault_rl){
        	*cmd_fr = *cmd_rr;
        	*cmd_rl = *cmd_fl;
        	return;
        }
    }

    if (n_fail == 1){
		if (fault_fl){
			*cmd_fl = *cmd_rl;
			return;
		}
		if (fault_fr){
			*cmd_fr = *cmd_rr;
			return;
		}
		if (fault_rl){
			*cmd_rl = *cmd_fl;
			return;
		}
		if (fault_rr){
			*cmd_rr = *cmd_fr;
			return;
		}
    }
}


void Control_Init(void)
{
    /* Inizializza stati interni della control law */
    ControlLaw_Init();
}

ControlOutput_t Control_Step()
{
    EncoderSnapshot_t enc;
    SupervisorSnapshot_t sup;


    /* === Lettura snapshot === */
    EncoderSnapshot_Read(&enc);
    SupervisorSnapshot_Read(&sup);


    ControlInput_t  in;
    ControlOutput_t out;

    in.speed_ref_rpm = sup.speed_ref_rpm * MAX_SPEED_RPM;
    in.steering_cmd  = sup.steering_cmd * MAX_TURN_RPM;

    float total_max_requested = fabsf(in.speed_ref_rpm) + fabsf(in.steering_cmd);
	if (total_max_requested > MAX_SPEED_RPM) {
		// Calcoliamo un fattore di scala per far rientrare tutto nel range 160 RPM
		float scale = MAX_SPEED_RPM / total_max_requested;
		in.speed_ref_rpm *= scale;
		in.steering_cmd *= scale;
	}



    in.rpm_sx_a = enc.wheel_speed_rpm[0];
    in.rpm_dx_a = enc.wheel_speed_rpm[1];
    in.rpm_sx_p = enc.wheel_speed_rpm[2];
    in.rpm_dx_p = enc.wheel_speed_rpm[3];


    //Se tutti gli encoder non funzionano allora uso open loop
    bool use_open_loop = (sup.degraded_mask & (FAULT_WHEEL_FL | FAULT_WHEEL_FR | FAULT_WHEEL_RL | FAULT_WHEEL_RR))
        == (FAULT_WHEEL_FL | FAULT_WHEEL_FR | FAULT_WHEEL_RL | FAULT_WHEEL_RR);


    //Se entrambi gli encoder di una coppia laterale (entrambi i sx o i dx) allora lo steering non è abilitato (a meno che non sia in open loop)
    bool disable_steering = (sup.degraded_mask & (FAULT_WHEEL_FL | FAULT_WHEEL_FR)) == (FAULT_WHEEL_FL | FAULT_WHEEL_FR) ||
        (sup.degraded_mask & (FAULT_WHEEL_RL | FAULT_WHEEL_RR)) == (FAULT_WHEEL_RL | FAULT_WHEEL_RR);



    if(disable_steering && !use_open_loop)
    	in.steering_cmd = 0;


    if(use_open_loop){
    	float v = in.speed_ref_rpm;
    	float omega = in.steering_cmd;

    	/* lato sinistro */
    	float u_left  = v - omega;

    	if (u_left > 80) u_left = 80;
    	if (u_left < -80) u_left  = -80;

    	/* lato destro */
    	float u_right = v + omega;

    	if (u_right > 80) u_right = 80;
        if (u_right < -80) u_right  = -80;
    	/* applica scaling open-loop */

    	out.u_sx_a = u_left;
    	out.u_dx_a = u_right;
    	out.u_sx_p = u_left;
    	out.u_dx_p = u_right;
    }
    else{
        ControlLaw_Step(&in, &out);
    }

    //SUCCEDE CHE CHE SE PASSO A RUOTA CRITICA NON VIENE PIù ESEGUITO E QUINDI (ho messo che in attuazione verifico se critical, se si metto a 0 diretto
    if( ((sup.degraded_mask & (FAULT_WHEEL_FL | FAULT_WHEEL_FR | FAULT_WHEEL_RL | FAULT_WHEEL_RR)) ||
    		(sup.critical_mask & (FAULT_WHEEL_FL | FAULT_WHEEL_FR | FAULT_WHEEL_RL | FAULT_WHEEL_RR))) && !use_open_loop){
    	Apply_Encoders_Fallback_Actuation(&out, sup);
    }

    return out;

}
