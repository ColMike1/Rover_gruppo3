/*
 * control_law.c
 *
 *  Created on: Jan 12, 2026
 *      Author: Sterm
 */


#include <actuation/actuation_step.h>
#include <encoder/encoder_step.h>
#include "control/control_law.h"
#include <math.h>


/* ===== Struttura PI ===== */
typedef struct {
    float Kp;
    float Ki;
    float e_prev;
    float u_prev;
    float out_limit;
} PI_Controller;

/* ===== Parametri ===== */
static const float Ts = 0.010f;   /* 10 ms */

/* ===== Controller ===== */
// 1. Master: Controlla la velocità media di tutto il rover
//static PI_Controller pi_global = {0.061f, 1.247f, 0.0f, 0.0f, 12.0f}; // Controllore troppo veloce(0.2 sec)
//static PI_Controller pi_global = {0.00235f, 0.0483f, 0.0f, 0.0f, 12.0f}; // Controllore più lento(5.44 sec)
//static PI_Controller pi_global = {0.003156f, 0.06485f, 0.0f, 0.0f, 12.0f}; // Controllore lento(5.44 sec)
static PI_Controller pi_global = {0.013f, 0.267f, 0.0f, 0.0f, 12.0f}; // Controllore finale(1 sec)

// 2. Sync Assi: Bilancia la velocità tra asse anteriore e posteriore
static PI_Controller pi_sync_asse = {0.005f,  0.189f,  0.0f, 0.0f, 2.4f};

// 3. Differenziale Posteriore: Bilancia DX e SX dietro
static PI_Controller pi_diff_p = {0.012f, 0.2f, 0.0f, 0.0f, 6.0f};
//0.5   2.0
// 4. Differenziale Anteriore: Bilancia DX e SX davanti
static PI_Controller pi_diff_a = {0.012f, 0.2f, 0.0f, 0.0f, 6.0f};

//Era 0.1f l'integrale!!!! e 0.8 il kp

//static PI_Controller pi_global    = {0.17f, 0.55f, 0.0f, 0.0f, 200.0f};
//static PI_Controller pi_sync_asse = {0.3f,  1.0f,  0.0f, 0.0f, 40.0f};
//static PI_Controller pi_diff_p    = {0.5f,  2.0f,  0.0f, 0.0f, 50.0f};
//static PI_Controller pi_diff_a    = {0.5f,  2.0f,  0.0f, 0.0f, 50.0f};









/* ===== PI incrementale ===== */
static float PI_Compute(PI_Controller *pi, float error, float dt)
{
    float u = pi->u_prev
            + (pi->Kp * (error - pi->e_prev))
            + (pi->Ki * dt * error);

    if (u >  pi->out_limit) u =  pi->out_limit;
    if (u < -pi->out_limit) u = -pi->out_limit;

    pi->e_prev = error;
    pi->u_prev = u;

    return u;
}




void ControlLaw_Init(void)
{
    pi_global.e_prev = pi_global.u_prev = 0.0f;
    pi_sync_asse.e_prev = pi_sync_asse.u_prev = 0.0f;
    //pi_d_p.e_prev = pi_diff_p.u_prev = 0.0f;
    pi_diff_a.e_prev = pi_diff_a.u_prev = 0.0f;
}



void ControlLaw_Step(const ControlInput_t *in, ControlOutput_t *out){

    float rpm_dx_p = in->rpm_dx_p;
    float rpm_sx_p = in->rpm_sx_p;
    float rpm_dx_a = in->rpm_dx_a;
    float rpm_sx_a = in->rpm_sx_a;

    /* === 0. Riferimenti fisici === */
    float speed_ref_rpm = in->speed_ref_rpm;
    float target_omega_rpm  = in->steering_cmd;


    /* === 1. Medie velocità  + differenziale attivo === */
    float rpm_avg_p = (rpm_dx_p + rpm_sx_p) / 2.0f;
    float rpm_avg_a = (rpm_dx_a + rpm_sx_a) / 2.0f;
    float rpm_global = (rpm_avg_p + rpm_avg_a) / 2.0f;

    float error_diff_p = (rpm_dx_p - rpm_sx_p) - (2.0f * target_omega_rpm);
    float error_diff_a = (rpm_dx_a - rpm_sx_a) - (2.0f * target_omega_rpm);


    /* 2. PI globale */
    float u_base = PI_Compute(&pi_global, speed_ref_rpm - rpm_global, Ts);

    /* 3. Sincronizzazione assi anteriore/posteriore */
    float correction_asse = PI_Compute(&pi_sync_asse, rpm_avg_a - rpm_avg_p, Ts);

    float u_target_p = u_base + correction_asse;
    float u_target_a = u_base - correction_asse;

    float diff_p =  PI_Compute(&pi_diff_p, error_diff_p, Ts);
    float diff_a =  PI_Compute(&pi_diff_a, error_diff_a, Ts);

    out->u_dx_p = u_target_p - diff_p;
    out->u_sx_p = u_target_p + diff_p;
    out->u_dx_a = u_target_a - diff_a;
    out->u_sx_a = u_target_a + diff_a;

}




